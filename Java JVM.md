*书山有路勤为径，学海无涯苦作舟*





# JVM

JVM 在运行时就是操作系统的一个进程实例。每个Java进程都有自己的 JVM 实例。



## 引导

* 请你谈谈你对JVM的理解？java8虚拟机和之前的变化更新？

* 什么是 OOM，什么是 StackOverFlow ？怎么分析？

* JVM常用调优参数有哪些？

* 内存快照如何抓取？怎么分析 Dump 文件？

* 谈谈JVM中，类加载你的认识？

* Java 是编译型语言还是解释型语言？

    介绍两者的定义；阐述java的执行机制



## JVM的位置

JRE 包含 JVM，具体是什么 ==TODO==



## JVM的体系结构

![image-20210622121116492](Java.assets/image-20210622121116492.png)	



## 类加载器

1. 虚拟机自带的加载器

2. Bootstrap 启动类加载器  /lib/rt.jar，在 Java 中返回 null，因为是由 C、C++实现的

3. Extend 扩展类加载器 /lib/ext

4. App 应用类加载器 



### class 文件

查看class 文件

*  `javap -verbose  xxx.class` 

* vscode 安装插件 hexdump，以16位进制查看



### 双亲委派机制

1. 加载器收到类加载请求
2. 将请求向上委托给父类加载器去完成，一直往上委托，直到启动类加载器
3. 启动类加载器检查是否能加载当前这个类，能加载就结束，使用当前的加载器；否则抛出异常，通知子加载器进行加载
4. 重复步骤 3

如果都找不到，则会抛出 Class Not Found 



## 沙箱安全机制

将Java代码限定在JVM特定的运行范围中，并且严格限制代码对本地系统资源访问。

系统资源包括：CPU、内存、文件系统、网络。



域：domain，每个域对应不同的权限

![image-20210622145856639](Java.assets/image-20210622145856639.png)	



### 组成部分



* 字节码校验器
* 类加载器
* 





## Native

> JNI 历史

Java 诞生初期，为了扩展 Java 的使用，融合不同编程语言为 Java 所用



首先标记了 Native 的方法，是 Java 自身无法执行，需要调用操作系统的方法库去实现



Java 在内存区域中专门开辟了一块标记区域：本地方法栈，登记所有 Native 方法。在最终执行的时候，通过本地方法接口（JNI）加载本地方法库中的方法。





## PC寄存器

程序计数器

每个线程都有一个程序计数器，线程私有的。就是一个指针，指向方法区中的方法字节码，在执行引擎读取下一条指令，是一个非常小的空间，可以忽略不计。



## 方法区

方法区是所有线程共享的，所有字段和方法字节码，以及一些特殊方法，如构造函数、接口代码也在此定义。



==静态变量、常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关==

总结下：static、final、class、运行时常量池



### 常量池

类型

* class 文件常量池
* 方法区的运行时常量池





## 栈

线程私有



栈内容

* 8 大基本类型
* 对象引用
* 实例方法







> 栈运行原理

入栈的方式 TODO



当方法执行时以帧的结构入栈

其父帧指向调用者

程序正在执行的方法，一定在栈的顶部

TODO



> 引发StackOverFlowError

例子：递归错误导致的方法之间循环调用



> 栈、堆、方法区的交互关系















### 栈帧

栈的单位是帧

包含

* 方法索引
* 输入输出参数
* 本地变量
* Class File
* 父帧
* 子帧





## 堆





## 对象实例化

> 实例化的方法

* new
* Class.newInstance
* Constructor.newInstance
* clone
* 反序列化

==注==：clone 和序列化并没有额外调用构造器



> 实例化的过程

简单类对象的实例化过程:

1. 在方法区加载类
2. 在栈内存申请空间，声明变量P
3. 在堆内存中开辟空间，分配对象地址
4. 在对象空间中，对对象的属性进行默认初始化，类成员变量显示初始化
5. 构造方法进栈，进行初始化
6. 初始化完成后，将堆内存中的地址赋给引用变量，构造方法出栈

[![简单类对象的实例化过程](Java.assets/UrHI8e.png)](https://s1.ax1x.com/2020/07/17/UrHI8e.png)

------

子类对象的实例化过程：

1. 在方法区先加载父类，再加载子类
2. 在栈中申请空间，声明变量P
3. 在堆内存中开辟空间，分配对象地址
4. 在对象空间中，对对象的属性（包括父类的属性）进行默认初始化
5. 子类构造方法进栈
6. 显示初始化父类的属性
7. 父类构造方法进栈，执行完毕出栈
8. 显示初始化子类的属性
9. 初始化完毕后，将堆内存中的地址值赋给引用变量P，子类构造方法出栈

[![子类对象的实例化过程](Java.assets/Ur7omq.png)](https://s1.ax1x.com/2020/07/17/Ur7omq.png)





## 三种JVM

通过 java -version 查看当前的虚拟机















## 新生区、老年区







## 永久区





## 堆内存调优

扩大内存





## GC

https://zhuanlan.zhihu.com/p/383179950

常用算法







## JMM









## 架构



1、类加载器子系统
2、执行引擎子系统
3、垃圾收集子系统



![在这里插入图片描述](Java.assets/20200514181107859.png)

 



编译和解释的区别：翻译的时间不同。





## 组成原理

执行流程

1. javac Math.java
2. java Math.class
3. 进入 JVM 流程

JVM 内部执行及组成部分：

1. 类装载子系统 —— 接收 class 文件
2. 运行时数据区（JVM 内存区）
    1. 堆
    2. 栈（线程）
    3. 本地方法栈
    4. 方法区（元空间）
    5. 程序计数器
3. 字节码执行引擎 —— 执行内存中加载的代码



![JVM内存模型](Java.assets/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png)	

## 运行时数据区

内存区是重点性能调优的地方







## JVM 指令







## 垃圾收集机制



### GC调优步骤

1、打印GC日志
-XX:+PrintGCDetails  -XX:+PrintGCTimeStamps  -XX:+PrintGCDateStamps  -Xloggc:./gc.log
Tomcat则直接加在JAVA_OPTS变量里
2、分析日志得到关键性指标
3、分析GC原因，调优JVM参数



## 调优工具

java6, 7, 8 的bin目录下自带jvisualvm工具，可以对java程序进行监控。如果要查看jvm gc的具体信息，比如heap堆中Eden，Old，则要装个插件visualgc。

java9及以后，就停止使用java VisualVM了，改用Graal VisualVM了。

官方地址：http://visualvm.github.io/index.html

![image-20210616090002721](Java.assets/image-20210616090002721.png)	

### 安装 GC 插件

参考：https://blog.csdn.net/yujianping_123/article/details/99549194





## 高并发调优

